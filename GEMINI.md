
# Project Overview

This project is a powerful automation tool for updating NuGet packages across multiple GitLab repositories. It features automated C# code migration and comprehensive tracking of merge requests. The tool not only updates package references but also intelligently migrates C# code to work with new package versions, eliminating manual code changes and reducing migration effort.

The project is composed of a Python application that orchestrates the process and a C# tool that performs the code migrations.

**Main Technologies:**

*   **Python:** The core application is written in Python 3.8+.
*   **C#:** The code migration tool is a .NET 9.0 console application.
*   **GitLab API:** The tool interacts with GitLab to manage repositories and merge requests.
*   **Roslyn:** The C# migration tool uses the Roslyn compiler platform for code analysis and transformation.
*   **YAML:** Migration rules are defined in YAML files.
*   **JSON:** Configuration can be provided in JSON or YAML format.

**Architecture:**

The application follows a modular architecture with a clear separation of concerns.

*   `run.py`: The main entry point of the application, responsible for parsing command-line arguments and orchestrating the workflow.
*   `src/`: Contains the core application logic.
    *   `actions/`: Business logic for different actions, such as updating NuGet packages and checking the status of merge requests.
    *   `core/`: Base classes and interfaces, such as the `Action` class.
    *   `providers/`: Modules for interacting with source control management systems, such as GitLab.
    *   `services/`: Services for handling configuration, code migration, and other tasks.
    *   `strategies/`: Different strategies for repository access (e.g., local clone vs. API).
*   `CSharpMigrationTool/`: The C# code migration tool.
*   `tests/`: Unit and integration tests for the Python application.

# Building and Running

**Prerequisites:**

*   Python 3.8 or higher
*   .NET 9.0 SDK or higher
*   GitLab API token with `api`, `read_repository`, and `write_repository` scopes.

**Installation:**

1.  Install Python dependencies:

    ```bash
    pip install -r requirements.txt
    ```

2.  Build the C# migration tool:

    ```bash
    cd CSharpMigrationTool
    dotnet build
    ```

**Running the Tool:**

The main entry point is `run.py`. It has two main actions: `update-nuget` and `check-status`.

**Update NuGet Packages:**

```bash
python run.py update-nuget --config-file config.yaml
```

This command updates the NuGet packages specified in the `config.yaml` file for the repositories listed in the same file. It also performs code migrations if `enable_code_migrations` is set to `true`.

**Check Merge Request Status:**

```bash
python run.py check-status --config-file config.yaml --tracking-file <tracking-file.json>
```

This command checks the status of the merge requests created by the `update-nuget` action. The `--tracking-file` argument should point to the JSON file generated by the `update-nuget` action.

**Testing:**

The project includes a test suite for the migration and rollback features.

*   Run all migration tests:

    ```bash
    python tests/run_migration_tests.py
    ```

*   Run only unit tests:

    ```bash
    python tests/run_migration_tests.py --unit
    ```

*   Run only integration tests:

    ```bash
    python tests/run_migration_tests.py --integration
    ```

# Development Conventions

*   **Coding Style:** The Python code follows the PEP 8 style guide.
*   **Testing:** The project uses `pytest` for testing. Unit tests are located in `tests/unit/` and integration tests are in `tests/integration/`.
*   **Configuration:** The application uses YAML or JSON for configuration.
*   **Code Migration Rules:** Code migrations are defined in a separate YAML file (`migration-config.yml`).
*   **Command-Line Interface:** The application has a command-line interface with two main commands: `update-nuget` and `check-status`.
*   **Modularity:** The code is organized into modules with a clear separation of concerns.
*   **Error Handling:** The tool includes robust error handling and a rollback mechanism.
